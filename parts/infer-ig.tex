\section{Interaction Graph Inference}\label{sec:infer-IG}

In order to infer a complete BRN, one has to find the Interaction Graph (IG) first, as some
constraints on the Parametrization rely on it.
Inferring the IG is an abstraction step which consists in determining the global influence of
components on each of its successors.

This section introduces first the notion of focal processes within a Process Hitting
(\pref{ssec:focal}) which is used to characterize well-formed Process Hittings for IG inference
in \pref{ssec:wf}, and as well used by the parametrization inference presented in \pref{sec:infer-K}.
Finally, the rules for infering the interactions between components from a Process Hitting are
described in \pref{ssec:infer-IG}.

We assume hereafter a global Process Hitting $(\PHs,\PHl,\PHa)$ on which the IG inference is to be
performed.

\subsection{Focal Processes}\label{ssec:focal}

Many of the inferences defined in the rest of this paper rely on the knowledge of \emph{focal
processes} w.r.t. a given context (a set of processes that are potentially present).
When such a context applies, we expect to (always) reach one focal process in a bound number of
actions.

Let us first define as $\PHa(S_a,\ctx)$ the set of actions on the sort $a$ having their hitter in
$\ctx$ and target in $S_a$ (\pref{eq:PHa-ctx}).
\begin{equation}
\PHa(S_a,\ctx) \DEF \{ \PHfrappe{b_i}{a_j}{a_k}\in\PHa \mid b_i\in\ctx \wedge a_j\in S_a \}
\enspace.
\label{eq:PHa-ctx}
\end{equation}

We denote $\focals(a,S_a,\ctx)$ the set of focal processes of sort $a$ in the context
$\ctx\cup S_a$
(\pref{def:focals}).

\begin{definition}[$\focals(a,S_a,\ctx)$]\label{def:focals}
Let us define the digraph $G = (V, E)$ where arcs are the bounces within the sort $a$
triggered by actions having their hitter in $\ctx$ and target in $S_a\subseteq L_a$:
\begin{align*}
E  & \DEF \{(a_j,a_k)\in (S_a \times \PHl_a) \mid 
			\exists\PHfrappe{b_i}{a_j}{a_k}\in \PHa(S_a,\ctx) \}
\\
V & \DEF S_a \cup \{ a_k\in L_a\mid \exists (a_j,a_k)\in E\}
\end{align*}
$\focals(a,S_a,\ctx)$ is the set of focal processes of sort $a$ in the context $\ctx$:
\[
\focals(a,S_a,\ctx) \DEF
\begin{cases}
\{ a_i \in V \mid \nexists (a_i,a_j)\in E\} & \text{if $G$ is acyclic},\\
\emptyset & \text{otherwise.}\\
\end{cases}
\]
\end{definition}

We say that a state $s\in\PHl$ \emph{matches} a context $\ctx$ if and only if
$\forall a\in\PHsort(\ctx), \PHget{s}{a}\in\ctx$, where $\PHsort(\ctx)$ is the set of sorts of
processes in $\ctx$.
From \pref{def:focals}, it derives that:
\begin{enumerate}
\item if $\focals(a,S_a,\ctx)=\emptyset$, there exists a 
state $s\in \PHl$ matching $\ctx\cup S_a$ such that $\forall n\in\mathbb N$ there
exists a sequence of $n+1$ actions in $\PHa(S_a,\ctx)$ successively playable in $s$.
\item if $\focals(a,S_a,\ctx)\neq\emptyset$, for all
state $s\in \PHl$ matching $\ctx\cup S_a$,
for any sequence of actions $h^1,\dots,h^k$ in $\PHa(S_a,\ctx)$ successively playable in $s$,
either
\begin{itemize}
\item $(s\play h^1\cdots h^k)[a] \in \focals(a,S_a,\ctx)$;
\item or, $\exists h^{k+1}\in \PHa(a,\ctx)$ playable in $s\play h^1\cdots h^k$.
\end{itemize}
Moreover $k\leq|\PHa(S_a,\ctx)|$ (no cycle of actions possible).
\end{enumerate}

In other words, if $\focals(a,S_a,\ctx)$ is empty, there exists a set of actions in
$\PHa(S_a,\ctx)$ that may be played as many number of times as we want (cycle);
if it is non-empty, all possible succession of actions in $\PHa(S_a,\ctx)$ have a bound length and
lead $a$ either to a process in $S_a$ that is not hit by processes in $\ctx$, or to a process in
$L_a\setminus S_a$.

\begin{example*}
In the Process Hitting of \pref{fig:runningPH-1}, we obtain:
\begin{align*}
\focals(a,L_a,\{b_0,c_0\}) &= \{ a_0 \}
&
\focals(a,L_a,\{b_1,c_1\}) &= \{ a_2 \}\\
\focals(a,L_a,\{b_1,c_0\}) &= \emptyset\enspace.
\end{align*}
\end{example*}

\subsection{Well-formed Process Hitting for Interaction Graph Inference}\label{ssec:wf}

The inference of an IG from a Process Hitting assumes there the Process Hitting defines two types of
sorts:
the sorts corresponding to BRN components, and the cooperative sorts.
This lead to the characterization of the \emph{well-formed} Process Hitting for IG inference.

The identification of sorts modelling components rely on the observation that their processes
represent (ordered) qualitative levels.
Hence an action on such a sort cannot make it bounce to process at a distance more than one.
The set of sorts satisfying such a condition is referred to as $\Gamma$
(\pref{eq:PH-components}).
Therefore, in the rest of this paper, $\Gamma$ denotes the set of components of the BRN to infer.

\begin{equation}
\Gamma \DEF \{a \in \PHs \mid \nexists \PHfrappe{b_i}{a_j}{a_k} \in \PHa, |j - k| > 1\} \\
\label{eq:PH-components}
\end{equation}

Any sort that does not act as a component should then be treated as a cooperative sort.
As explained in \pref{ssec:PH}, the role of a cooperative sort $\upsilon$ is two compute the current
state of set of cooperating processes.
Hence, for each sub-state $\sigma$ formed by the sorts hitting $\upsilon$, $\upsilon$ should
converge to a focal process.
This is expressed by \pref{pro:wf-cooperative-sort}, where
the set of sorts having an action on a given sort $a$ is given by 
$\PHdirectpredec{a}$ (\pref{eq:ph_direct_predec})
and $\PHproc(\sigma)$ is the set of processes that compose the sub-state $\sigma$.

\begin{equation}
\forall a \in \PHs, \PHdirectpredec{a} \DEF \{b \in \PHs \mid \exists \PHfrappe{b_i}{a_j}{a_k}\in\PHa \}
\label{eq:ph_direct_predec}
\end{equation}

\begin{property}[Well-formed cooperative sort]\label{pro:wf-cooperative-sort}
A sort $\upsilon\in\PHs$ is a well-formed cooperative sort if and only if
each configuration $\sigma$ of its predecessors leads $\upsilon$ to a unique focal process,
denoted by $\upsilon(\sigma)$:
\[
\forall \sigma \in {\textstyle\prod_{
a\in\PHdirectpredec{\upsilon} \wedge a\neq \upsilon}}
\PHl_{a},
\focals(\upsilon,\PHl_\upsilon,\PHproc(\sigma)\cup \PHl_\upsilon) = \{ \upsilon(\sigma) \}\]
\end{property}

Such a property allows a large variety of definition of a cooperative sort, but
for the sake of simplicity, does not allow the existence of multiple focal processes.
While this may be easily extended to (the condition becomes 
$\focals(\upsilon,\PHl_\upsilon, \PHproc(\sigma)\cup \PHl_\upsilon)\neq\emptyset$), it makes some
hereafter equations a bit more complex to read as they should handle set of focal processes instead
of a unique focal process.


Finally, \pref{pro:wf-ph} sums up the conditions for a Process Hitting to be suitable for IG
inference.
In addition of having either component sorts or well-formed cooperative sorts, we also impose that
there is no cycle between cooperative sorts, and that
sorts being not hit (\ie{}, serving as invariant environment) are components.

\begin{property}[Well-formed Process Hitting for IG inference]\label{pro:wf-ph}
A Process Hitting is well-formed for IG inference if and only if the following conditions are
verified:
\begin{itemize}
\item 
each sort $a\in\PHs$ either belongs to $\Gamma$, or is a well-formed cooperative sort;
\item 
there is no cycle between cooperative sorts
(the digraph $(\Sigma,\{(a,b)\in(\Sigma\times\Sigma)\mid \exists \PHfrappe{a_i}{b_j}{b_k}\in\PHa
\wedge a\neq b\wedge \{a,b\}\cap\Gamma=\emptyset \})$ is
acyclic);
\item 
sorts having no action hitting them belong to $\Gamma$
($\{ a \in \Sigma\mid \nexists \PHfrappe{b_i}{a_j}{a_k}\in\PHa\} \subset \Gamma$).
\end{itemize}
\end{property}

\begin{comment}
\begin{center}
\begin{tikzpicture}
% Sortes
\TSetSortLabel{a}{b}
\TSetSortLabel{b}{c}
\TSetSortLabel{z}{a}
\TSetSortLabel{ab}{bc}
\TSort{(0,3)}{a}{2}{l}
\TSort{(0,0)}{b}{2}{l}
\TSetTick{ab}{0}{00}
\TSetTick{ab}{1}{01}
\TSetTick{ab}{2}{10}
\TSetTick{ab}{3}{11}
\TSort{(3,0.5)}{ab}{4}{r}
\TSort{(6,1)}{z}{3}{r}

% Actions de màj de ab
\THit{a_1}{}{ab_0}{.west}{ab_2}
\THit{a_1}{}{ab_1}{.west}{ab_3}
\path[bounce,bend left] \TBounce{ab_0}{}{ab_2}{.south} \TBounce{ab_1}{}{ab_3}{.south};

\THit{a_0}{}{ab_2}{.west}{ab_0}
\THit{a_0}{}{ab_3}{.west}{ab_1}
\path[bounce,bend right] \TBounce{ab_2}{}{ab_0}{.north} \TBounce{ab_3}{}{ab_1}{.north};

\THit{b_0}{}{ab_3}{.west}{ab_2}
\THit{b_0}{}{ab_1}{.west}{ab_0}
\THit{b_1}{}{ab_0}{.west}{ab_1}
\THit{b_1}{}{ab_2}{.west}{ab_3}
\path[bounce,bend right] \TBounce{ab_1}{}{ab_0}{.north} \TBounce{ab_3}{}{ab_2}{.north};
\path[bounce,bend left] \TBounce{ab_0}{}{ab_1}{.south} \TBounce{ab_2}{}{ab_3}{.south};

% Arcs sortant de ab
\THit{ab_2}{}{z_1}{.north west}{z_2}
\THit{ab_2}{}{z_0}{.north west}{z_1}
\path[bounce,bend left] \TBounce{z_1}{}{z_2}{.south} \TBounce{z_0}{}{z_1}{.south};
\THit{ab_3}{}{z_2}{.south west}{z_1}
\THit{ab_3}{}{z_0}{.north west}{z_1}
\path[bounce,bend left] \TBounce{z_2}{bend right}{z_1}{.north} \TBounce{z_0}{}{z_1}{.south};
\THit{ab_1}{}{z_2}{.south west}{z_1}
\THit{ab_1}{}{z_1}{.south west}{z_0}
\path[bounce,bend right] \TBounce{z_2}{}{z_1}{.north} \TBounce{z_1}{}{z_0}{.north};
\THit{ab_0}{}{z_2}{.south west}{z_1}
\THit{ab_0}{}{z_1}{.south west}{z_0}
\path[bounce,bend right] \TBounce{z_2}{}{z_1}{.north} \TBounce{z_1}{}{z_0}{.north};
\end{tikzpicture}
\end{center}
\end{comment}

\subsection{Interaction Inference}\label{ssec:infer-IG}

At this point we can divide the set of sorts $\PHs$ into components ($\Gamma$) and cooperative sorts
($\PHs \setminus \Gamma$) that will not appear in the IG. 
We define in \pref{eq:ph_predec} the predecessors of a sort $a$, that are the sorts influencing $a$
by considering direct actions and possible intermediate cooperative sorts.
The predecessors of $a$ that are components are the regulators of $a$, noted $\PHpredecgene{a}$
(\pref{eq:regulators}).
\begin{align}
\begin{split}
\forall a \in \PHs, \PHpredec{a} &\DEF \{b \in \PHs \mid \exists n \in \mathbb{N}^*, \exists
(c^k)_{k \in [0;n]} \in \PHs^{n+1}, \\
                                   & \quad \quad c^0 = b \wedge c^n = a \\
                                   & \quad \quad \wedge \forall k \in \llbracket 0 ; n-1 \rrbracket,
								   c^k \in \PHdirectpredec{c^{k+1}} \cap (\PHs\setminus\Gamma)\}
\end{split}
\label{eq:ph_predec}
\\
\forall a\in \PHs, \PHpredecgene{a} & \DEF \PHpredec{a} \cap \Gamma
\label{eq:regulators}
\end{align}

We now aim to determine what kind of influence gets each component from its component predecessors.
Let $a \in \Gamma$ be a component and $b \in \PHpredecgene{b}$ a component that may influence it.
\pref{eq:cooperating-with-b} defines 
$\gamma(b\rightarrow a)$ as the set of components cooperating with $b$ to hit $a$, including $b$ and
$a$.
We note $\configs$ the set of configurations of such components.
\begin{align}
\begin{split}
\gamma(b\rightarrow a)  &\DEF \{ a, b \} \cup \{ c \in \Gamma \mid 
			\exists \upsilon\in\PHs\setminus\Gamma,
				\upsilon\in\PHpredec{a} \wedge \{b,c\}\subset\PHpredec{\upsilon} \}
\end{split}
\label{eq:cooperating-with-b}
\\
\configs & \DEF \textstyle\prod_{c\in\gamma(b\rightarrow a)} L_c
\label{eq:configurations}
\end{align}

Given a configuration $\sigma\in\configs$, $\ctx(\sigma)$ refers to the set of focal processes
regulated by $b$ that can hit the sort $a$ (\pref{eq:ctx-sigma}).
This set is composed of the active process of sort $b$ ($\sigma[b]$), and the focal process (assumed
unique) of the cooperative sorts $\upsilon$ hitting $a$ that have $b$ as a predecessor.
The evaluation of the focal process of $\upsilon$ in context $\sigma$, denoted $\upsilon(\sigma)$,
rely on \pref{pro:wf-cooperative-sort}, which gives its value when all the direct predecessors of
$\upsilon$ are defined in $\sigma$.
When a predecessor $\upsilon'$ is not in $\sigma$, we extend the evaluation by recursively computing
the focal value of $\upsilon'$ is $\sigma$, as stated in \pref{eq:cooperative-eval}.
Because there is no cycle between cooperative sorts, this recursive evaluation of $\upsilon(\sigma)$
always terminates.

\begin{align}
\ctx(\sigma) & \DEF \{ \sigma[b] \} \cup \{ \upsilon(\sigma) \mid
\upsilon\in\PHdirectpredec{a} \wedge  \upsilon \notin\Gamma \wedge b\in \PHpredecgene{\upsilon} \}
\label{eq:ctx-sigma}
\\
\upsilon(\sigma) & \DEF
\upsilon(\sigma \uplus \state{\upsilon'(\sigma) \mid 
	\upsilon'\in\PHdirectpredec{\upsilon} \wedge
	\upsilon'\in\PHs\setminus\Gamma })
\label{eq:cooperative-eval}
\end{align}

We aim at infering that $b$ actives (inhibits) $a$ if there exists a configuration where increasing
(decreasing) the level of $b$ makes possible the increase (decrease) of the level of $a$.
This is analogous to standard IG inferences from boolean and discrete maps 
\cite{RiCo07}.

\todo{explications détaillées pour $b\neq a$}

\todo{\pref{eq:bounces}, where $\PHa(\{a_k\}, \varsigma(\sigma))$ is the set of actions
targeting $a_k$ and having their hitter in $\varsigma(\sigma)$ (\pref{eq:PHa-ctx})}
We note $\sigma\{b_i\}$ the configuration $\sigma$ where the process of sort $b$ has been replaced
by $b_i$.

\begin{equation}
\f{bounces}(a_k,\varsigma(\sigma)) \DEF 
\begin{cases}
\{ a_k \} \quad\text{if }\nexists \PHfrappe{c_i}{a_k}{a_l}\in \PHa \wedge c_i \in \ctx(\sigma) \\
\{ a_l \mid \exists \PHfrappe{c_i}{a_k}{a_l}\in \PHa \wedge c_i \in \ctx(\sigma) \}
& \text{otherwise.}
\end{cases}
\label{eq:bounces}
\end{equation}

\todo{explain when $b = a$}

\begin{equation}
\epsilon(a_i, \ctx(\sigma)) \DEF
\begin{cases}
\varnothing & \text{if }\f{bounces}(a_i,\ctx(\sigma))=\{ a_i \} \\
+ &  \text{if }\f{bounces}(a_i,\ctx(\sigma)) = \{ a_{i+1} \}\\
- &  \text{if }\f{bounces}(a_i,\ctx(\sigma)) = \{ a_{i-1} \}\\
\pm & \text{otherwise.}
\end{cases}
\label{eq:epsilon}
\end{equation}

\begin{definition}[Interaction Graph Inference]\label{def:inference-IG}
\todo{intro}
\begin{align}
\begin{split}
\forall b\in\PHs, b\neq a, \\
b\xrightarrow s a \in \IG & \Longleftrightarrow
	\exists b_i,b_j\in \PHl_b, i < j, \exists \sigma\in\configs \\
& \qquad
	\exists a_{l,1}\in\f{bounces}(\sigma[a],\varsigma[\sigma\{b_i\}]), \\
& \qquad
	\exists a_{l,2}\in\f{bounces}(\sigma[a],\varsigma[\sigma\{b_j\}]), \\
& \qquad\qquad
			s = \f{sign}(a_{l,2} - a_{l,1})
\end{split}
\label{eq:IG-inference-b}
\\
\begin{split}
a \xrightarrow s a \notin\IG & \Longleftrightarrow
(\PHpredecgene{a} = \{a\} \wedge \focals(a, \PHl_a, \PHl_a) = [a_i;a_j], i\leq j) \\
& \qquad \exists a_k \in L_a, \forall \sigma\in\configs, \\
& \qquad \forall i \in [0;k-1], \epsilon(a_i, \ctx(\sigma))\in \{s,\varnothing\} \\
& \qquad \forall j \in [k+1;l_a], \epsilon(a_j, \ctx(\sigma))\in \{\bar s,\varnothing\}
\end{split}
\end{align}
where $s \in \{ +, - \}$, $\bar s = + \EQDEF s = -$, $\bar s = - \EQDEF s = +$,
$\f{sign}(n) = + \EQDEF n > 0$,
$\f{sign}(n) = - \EQDEF n < 0$,
and $\f{sign}(0) \EQDEF 0$.
\end{definition}


\todo{threshold}

\todo{illustrate some of the above definitions with (parts of) the running examples}

\todo{Discuss of errors/inconclusive cases}


